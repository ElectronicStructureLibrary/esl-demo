module esl_hamiltonian_pw_m
  use prec, only : dp,ip
  use elsi
  use elsi_rci
  use elsi_rci_constants
  use elsi_rci_omm
  use elsi_rci_precision, only:r8, i4

  use esl_basis_pw_m
  use esl_grid_m
  use esl_potential_m
  use esl_states_m
  use esl_utils_pw_m

  use mpi_dist
#ifdef WITH_MPI
  use mpi
#endif


  implicit none
  private

  public ::                          &
      hamiltonian_pw_t,                &
      hamiltonian_pw_apply,            &
      hamiltonian_pw_apply_local

  type work_matrix_t
    complex(kind=dp), allocatable :: mat(:,:)
  end type work_matrix_t

  !Data structure for the Hamiltonian
  type hamiltonian_pw_t
    type(elsi_handle)    :: e_h
    type(mpi_dist_t)     :: dist

    type(potential_t), pointer :: pot
  contains
    private
    procedure, public :: init
    procedure, public :: eigensolver
    final :: cleanup
  end type hamiltonian_pw_t

contains

  !Initialize the Hamiltonian
  !----------------------------------------------------
  subroutine init(this, pot, comm)
    class(hamiltonian_pw_t) :: this
    type(potential_t), target, intent(in) :: pot
    integer,        intent(in) :: comm

    this%pot => pot

    !call this%dist%init_(comm, 1)

    !call elsi_init(this%e_h, solver, 1, 0, matrix_size, real(states%nel,kind=dp), states%nstates)

  end subroutine init

  !Release
  !----------------------------------------------------
  subroutine cleanup(this)
    type(hamiltonian_pw_t) :: this

!    call this%dist%delete_()

    nullify(this%pot)

  end subroutine cleanup

  !Eigensolver
  !----------------------------------------------------
  subroutine eigensolver(this, states, pw)
    class(hamiltonian_pw_t) :: this
    type(states_t), intent(inout) :: states
    type(basis_pw_t), intent(in)    :: pw

    integer :: ii, jj 
    real(kind=r8), allocatable :: result_in(:)
    type(rci_instr)      :: iS
    integer(kind=i4) :: task, m, n, ijob
    real(kind=r8) :: e_min = 0.0_r8
    real(kind=r8) :: cg_tol = 0.0001_r8
    integer(kind=i4) :: max_iter = 100
    logical :: long_out = .false.
    type(work_matrix_t), allocatable :: work(:)
    complex(kind=dp), external :: zdotc


    m = pw%npw 
    n = states%nstates

    !OMM needs 28 matrices
    allocate(work(1:28))
    do ii = 1, 11
      allocate(work(ii)%mat(1:m,1:n))
    end do
    do ii = 21, 28
      allocate(work(ii)%mat(1:n,1:n))
    end do

    !We copy the states in work(1)
    !TODO support spin and kpoint
    do ii=1,n
      work(1)%mat(1:pw%npw, ii) = states%states(1,1,ii)%zcoef(1:pw%npw)
    end do

    allocate (result_in(1))
    ijob = -1
    do
        call rci_omm(ijob, iS, task, result_in, m, n, &
                     e_min, cg_tol, max_iter, long_out)

        select case (task)
        case (ELSI_RCI_NULL)
        case (ELSI_RCI_CONVERGE)
            exit
        case (ELSI_RCI_H_MULTI)
            do ii = 1,iS%n
              call hamiltonian_pw_apply(this%pot, pw, work(iS%Aidx)%mat(1:iS%m,ii),  work(iS%Bidx)%mat(1:iS%m,ii))
            end do
        case (ELSI_RCI_S_MULTI)
            !No overlap matrix
            work(iS%Bidx)%mat(1:iS%m,1:iS%n) = work(iS%Aidx)%mat(1:iS%m,1:iS%n)
        case (ELSI_RCI_P_MULTI)
            ! No preconditioner
            work(iS%Bidx)%mat(1:iS%m,1:iS%n) = work(iS%Aidx)%mat(1:iS%m,1:iS%n) 
        case (ELSI_RCI_GEMM)
             call zgemm(iS%TrA, iS%TrB, iS%m, iS%n, iS%k,iS%alpha,     &
               work(iS%Aidx)%mat(1,1), size(work(iS%Aidx)%mat,1), &
               work(iS%Bidx)%mat(1,1), size(work(iS%Bidx)%mat,1), &
               iS%beta, work(iS%Bidx)%mat(1,1), iS%m)
        case (ELSI_RCI_AXPY)
          do ii = 1,iS%n
            call zaxpy(iS%m, iS%alpha, work(iS%Aidx)%mat(1,ii), 1, work(iS%Bidx)%mat(1,ii),1)
          end do
        case (ELSI_RCI_COPY)
          if(iS%TrA == 'N') then
            work(iS%Bidx)%mat(1:iS%m,1:iS%n) = work(iS%Aidx)%mat(1:iS%m,1:iS%n)
          end if
          if(iS%TrA == 'T') then
            do ii = 1, iS%m
              do jj = 1, iS%n
                work(iS%Bidx)%mat(ii,jj) = work(iS%Aidx)%mat(jj,ii)
              end do
            end do
          end if 
          if(iS%TrA == 'C') then
            do ii = 1, iS%m
              do jj = 1, iS%n
                work(iS%Bidx)%mat(ii,jj) = conjg(work(iS%Aidx)%mat(jj,ii))
              end do
            end do
          end if
        case (ELSI_RCI_TRACE)
          result_in(1) = 0.d0
          do ii = 1, iS%n
            result_in(1) = result_in(1) + real(work(iS%Aidx)%mat(ii,ii),kind=dp)
          end do
        case (ELSI_RCI_DOT)
          result_in(1) = 0.d0
          do ii = 1, iS%m
            do jj = 1, iS%n
              result_in(1) = real(work(iS%Aidx)%mat(ii,jj)*work(iS%Bidx)%mat(ii,jj),kind=dp)
            end do
          end do
        case (ELSI_RCI_SCALE)
          do ii = 1,iS%n
            call zscal(iS%m, iS%alpha, work(iS%Aidx)%mat(1,ii), 1)
          end do
        case default
        end select
    end do

    !We copy the states back from work(1)
    !Work(2) contains H|\psi>
    !TODO support spin and kpoint
    do ii=1,n
      states%states(1,1,ii)%zcoef(1:pw%npw) = work(1)%mat(1:pw%npw, ii)
      states%eigenvalues(1,1,ii) = real(zdotc(pw%npw, work(1)%mat(1:pw%npw, ii), 1,  work(2)%mat(1:pw%npw, ii),1),kind=dp)
    end do


    deallocate (result_in)
    do ii = 1, 28
      deallocate(work(ii)%mat)
    end do
    deallocate(work)

  end subroutine eigensolver


  !Apply the Hamiltonian matrix
  !----------------------------------------------------
  subroutine hamiltonian_pw_apply(pot, pw, psi, hpsi)
    type(potential_t),  intent(in)    :: pot
    type(basis_pw_t),   intent(in)    :: pw
    complex(dp),      intent(in)      :: psi(:)
    complex(dp),      intent(inout)   :: hpsi(:)

    integer :: ic

    !We apply the Laplacian
    do ic = 1,pw%npw
      hpsi(ic) = -0.5d0*psi(ic)*pw%gmod2(ic)
    end do

    call hamiltonian_pw_apply_local(pw, pot, psi, hpsi)

  end subroutine hamiltonian_pw_apply

  !Apply the local part of the Hamitonian to a wavefunction
  !----------------------------------------------------
  subroutine hamiltonian_pw_apply_local(pw, pot, psi, hpsi)
    type(basis_pw_t),       intent(in)    :: pw
    type(potential_t),      intent(in)    :: pot
    complex(dp),            intent(in)    :: psi(:)
    complex(dp),            intent(inout) :: hpsi(:)

    integer :: ip
    complex(kind=dp), allocatable :: psi_rs(:), vpsi_rs(:)

    !TODO: Here there is no spin

    allocate(psi_rs(1:pw%grid%np))
    allocate(vpsi_rs(1:pw%grid%np))

    call pw2grid(pw%grid, pw%gmap, pw%ndims, pw%npw, psi, psi_rs) 
    !Note that hartree contains the external potential (from PSolver)
    forall(ip = 1:pot%np)
      vpsi_rs(ip) = vpsi_rs(ip) + (pot%hartree(ip) + pot%vxc(ip))*psi_rs(ip)
    end forall
    call grid2pw(pw%grid, pw%gmap, pw%ndims, pw%npw, vpsi_rs, hpsi, .true.)

    deallocate(psi_rs)
    deallocate(vpsi_rs)

  end subroutine hamiltonian_pw_apply_local

end module esl_hamiltonian_pw_m
